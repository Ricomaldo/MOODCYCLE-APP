// services/ChatService.js
// Service de gestion du chat avec API MoodCycle
// Gestion cache + personnalisation progressive + m√©moire conversationnelle

import AsyncStorage from '@react-native-async-storage/async-storage';
import { useOnboardingStore } from '../stores/useOnboardingStore.js';
import ContextFormatter from './ContextFormatter.js';
import { getApiRequestConfig } from '../config/api.js';

const CACHE_KEY = 'conversation_context_v1';
const DEVICE_ID_KEY = 'device_id_v1';
// ‚úÖ NOUVEAU : Cl√© pour l'historique conversationnel
const HISTORY_KEY = 'conversation_history_v1';
const MAX_HISTORY_EXCHANGES = 4; // 4 √©changes max en m√©moire

// R√©ponses fallback pour simulation locale
const FALLBACK_RESPONSES = {
  "Comment te sens-tu aujourd'hui?": "Je me sens plut√¥t bien, et toi?",
  "Pourquoi je me sens si fatigu√©e?": "La fatigue est normale pendant cette phase de ton cycle. Ton corps travaille dur et tes hormones fluctuent. Est-ce que tu arrives √† te reposer suffisamment?",
  "Quels aliments me recommandes-tu?": "Pendant ta phase folliculaire actuelle, des aliments riches en fer et en prot√©ines seraient b√©n√©fiques, comme les l√©gumes verts, les lentilles et les ≈ìufs. As-tu des pr√©f√©rences alimentaires particuli√®res?"
};

class ChatService {
  
  constructor() {
    this.cachedContext = null;
    this.deviceId = null;
    this.isInitialized = false;
    // ‚úÖ NOUVEAU : Cache m√©moire pour l'historique
    this.conversationHistory = [];
  }

  /**
   * üîß INITIALISATION DU SERVICE
   * G√©n√®re device ID et pr√©pare le contexte
   */
  async initialize() {
    if (this.isInitialized) return;
    
    try {
      // G√©n√©rer ou r√©cup√©rer Device ID
      this.deviceId = await this.getOrGenerateDeviceId();
      
      // Marquer comme initialis√©
      this.isInitialized = true;
      
      console.log('üöÄ ChatService initialis√© avec Device ID:', this.deviceId);
    } catch (error) {
      console.error('üö® Erreur initialisation ChatService:', error);
      // Continuer avec des valeurs par d√©faut
      this.deviceId = 'fallback-device-id';
      this.isInitialized = true;
    }
  }

  /**
   * üì± G√âN√âRATION/R√âCUP√âRATION DEVICE ID
   */
  async getOrGenerateDeviceId() {
    try {
      // V√©rifier si d√©j√† stock√©
      let deviceId = await AsyncStorage.getItem(DEVICE_ID_KEY);
      
      if (!deviceId) {
        // G√©n√©rer nouveau ID (fallback compatible)
        deviceId = this.generateDeviceId();
        await AsyncStorage.setItem(DEVICE_ID_KEY, deviceId);
      }
      
      return deviceId;
    } catch (error) {
      console.warn('üö® Erreur Device ID, fallback:', error);
      return this.generateDeviceId();
    }
  }

  /**
   * üîÑ G√âN√âRATION ID UNIQUE
   */
  generateDeviceId() {
    // Fallback compatible cross-platform
    const timestamp = Date.now().toString(36);
    const random = Math.random().toString(36).substr(2, 9);
    return `moodcycle-${timestamp}-${random}`;
  }

  /**
   * üéØ INITIALISATION CONTEXTE (PREMIER MESSAGE)
   * Calcule et met en cache le contexte personnalis√© + charge historique
   */
  async initializeContext() {
    try {
      // Valider donn√©es onboarding
      const validationResult = this.validateOnboardingData();
      if (!validationResult.isValid) {
        console.warn('üö® Donn√©es onboarding invalides:', validationResult.errors);
        return this.createFallbackContext();
      }

      // ‚úÖ NOUVEAU : Charger historique conversationnel
      await this.loadConversationHistory();

      // G√©n√©rer contexte personnalis√©
      const context = ContextFormatter.formatCompact();
      
      // ‚úÖ NOUVEAU : Ajouter historique au contexte
      context.conversationHistory = this.conversationHistory;
      
      // Valider le contexte g√©n√©r√©
      const contextValidation = ContextFormatter.validateContext(context);
      if (!contextValidation.valid) {
        console.warn('üö® Contexte g√©n√©r√© invalide:', contextValidation.errors);
        return this.createFallbackContext();
      }

      // Mettre en cache
      await this.cacheContext(context);
      this.cachedContext = context;
      
      console.log('‚úÖ Contexte initialis√© et mis en cache avec historique:', this.conversationHistory.length, '√©changes');
      return context;
      
    } catch (error) {
      console.error('üö® Erreur initialisation contexte:', error);
      return this.createFallbackContext();
    }
  }

  /**
   * üîç VALIDATION DONN√âES ONBOARDING
   */
  validateOnboardingData() {
    try {
      const onboardingData = useOnboardingStore.getState();
      const errors = [];

      // V√©rifications critiques
      if (!onboardingData.userInfo) {
        errors.push('UserInfo manquant');
      }

      if (!onboardingData.preferences) {
        errors.push('Pr√©f√©rences manquantes');
      }

      if (!onboardingData.melune) {
        errors.push('Configuration Melune manquante');
      }

      // V√©rifier si onboarding au moins partiellement rempli
      const hasMinimumData = 
        onboardingData.userInfo?.journeyStarted || 
        onboardingData.completed ||
        Object.keys(onboardingData.preferences || {}).length > 0;

      if (!hasMinimumData) {
        errors.push('Donn√©es onboarding insuffisantes');
      }

      return {
        isValid: errors.length === 0,
        errors,
        hasMinimumData
      };
    } catch (error) {
      console.error('üö® Erreur validation onboarding:', error);
      return {
        isValid: false,
        errors: ['Erreur validation'],
        hasMinimumData: false
      };
    }
  }

  /**
   * üõ°Ô∏è CONTEXTE FALLBACK
   */
  createFallbackContext() {
    return {
      persona: 'emma',
      userProfile: {
        prenom: null,
        ageRange: null
      },
      currentPhase: 'non d√©finie',
      preferences: {
        symptoms: 3,
        moods: 3,
        phyto: 3,
        phases: 3,
        lithotherapy: 3,
        rituals: 3
      },
      communicationTone: 'bienveillant'
    };
  }

  /**
   * üíæ GESTION CACHE CONTEXTE
   */
  async cacheContext(context) {
    try {
      const cacheData = {
        context,
        timestamp: Date.now(),
        version: '1.0'
      };
      
      await AsyncStorage.setItem(CACHE_KEY, JSON.stringify(cacheData));
    } catch (error) {
      console.warn('üö® Erreur cache contexte:', error);
    }
  }

  /**
   * üì• R√âCUP√âRATION CACHE CONTEXTE
   */
  async getCachedContext() {
    try {
      const cached = await AsyncStorage.getItem(CACHE_KEY);
      
      if (!cached) return null;
      
      const cacheData = JSON.parse(cached);
      
      // V√©rifier expiration (24h)
      const age = Date.now() - cacheData.timestamp;
      const maxAge = 24 * 60 * 60 * 1000; // 24h
      
      if (age > maxAge) {
        console.log('üïí Cache contexte expir√©');
        await AsyncStorage.removeItem(CACHE_KEY);
        return null;
      }
      
      return cacheData.context;
    } catch (error) {
      console.warn('üö® Erreur lecture cache:', error);
      return null;
    }
  }

  /**
   * üí¨ ENVOI MESSAGE PRINCIPAL
   * Gestion cache + historique + appel API + fallback
   */
  async sendMessage(message, isFirstMessage = false) {
    // S'assurer que le service est initialis√©
    if (!this.isInitialized) {
      await this.initialize();
    }

    try {
      // R√©cup√©rer ou initialiser contexte
      let context = this.cachedContext;
      
      if (!context) {
        context = await this.getCachedContext();
      }
      
      if (!context || isFirstMessage) {
        console.log('üéØ Initialisation contexte pour premier message');
        context = await this.initializeContext();
      }

      // ‚úÖ NOUVEAU : Ajouter historique au contexte si pas d√©j√† pr√©sent
      if (!context.conversationHistory) {
        await this.loadConversationHistory();
        context.conversationHistory = this.conversationHistory;
      }

      // Appel API
      const response = await this.callChatAPI(message, context);
      
      // ‚úÖ NOUVEAU : Sauvegarder √©change dans l'historique
      await this.saveMessageExchange(message, response);
      
      return {
        success: true,
        message: response,
        source: 'api'
      };
      
    } catch (error) {
      console.error('üö® Erreur sendMessage:', error);
      
      // Fallback simulation locale
      const fallbackResponse = this.getFallbackResponse(message);
      
      // ‚úÖ NOUVEAU : Sauvegarder m√™me les fallbacks
      if (fallbackResponse.success) {
        await this.saveMessageExchange(message, fallbackResponse.message);
      }
      
      return fallbackResponse;
    }
  }

  /**
   * üåê APPEL API CHAT
   */
  async callChatAPI(message, context) {
    const apiConfig = getApiRequestConfig(this.deviceId);
    
    const response = await fetch(`${apiConfig.baseURL}/api/chat`, {
      method: 'POST',
      headers: apiConfig.headers,
      body: JSON.stringify({
        message,
        context
      }),
      timeout: apiConfig.timeout
    });

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    const data = await response.json();
    
    // Debug API response
    if (__DEV__) {
      console.log('üîç API Response compl√®te:', data);
    }
    
    // L'API retourne un format : { response, cost, timestamp, tokensUsed }
    if (data.response) {
      return data.response;
    }
    
    // Format alternatif avec success (si l'API change)
    if (data.success === false) {
      throw new Error(data.error?.message || 'Erreur API inconnue');
    }

    if (data.data?.message) {
      return data.data.message;
    }
    
    if (data.message) {
      return data.message;
    }

    // Si aucun format reconnu
    throw new Error('Format de r√©ponse API non reconnu');
  }

  /**
   * üîÑ FALLBACK SIMULATION LOCALE
   */
  getFallbackResponse(message) {
    const fallbackMessage = FALLBACK_RESPONSES[message] || 
      "Je comprends. Pendant cette phase de ton cycle, ton corps traverse de nombreux changements. Comment puis-je t'accompagner aujourd'hui ?";

    return {
      success: true,
      message: fallbackMessage,
      source: 'fallback'
    };
  }

  /**
   * ‚úÖ NOUVEAU : CHARGEMENT HISTORIQUE DEPUIS ASYNCSTORAGE
   */
  async loadConversationHistory() {
    try {
      const historyJson = await AsyncStorage.getItem(HISTORY_KEY);
      
      if (!historyJson) {
        this.conversationHistory = [];
        return;
      }
      
      const historyData = JSON.parse(historyJson);
      
      // Validation format
      if (Array.isArray(historyData.exchanges)) {
        this.conversationHistory = historyData.exchanges;
        console.log('üìö Historique charg√©:', this.conversationHistory.length, '√©changes');
      } else {
        console.warn('üö® Format historique invalide, reset');
        this.conversationHistory = [];
      }
      
    } catch (error) {
      console.warn('üö® Erreur chargement historique:', error);
      this.conversationHistory = [];
    }
  }

  /**
   * ‚úÖ NOUVEAU : SAUVEGARDE √âCHANGE DANS HISTORIQUE
   */
  async saveMessageExchange(userMessage, meluneResponse) {
    try {
      // Cr√©er nouvel √©change
      const newExchange = {
        user: userMessage,
        melune: meluneResponse,
        timestamp: Date.now()
      };
      
      // Ajouter au d√©but (plus r√©cent en premier)
      this.conversationHistory.unshift(newExchange);
      
      // Limiter √† MAX_HISTORY_EXCHANGES
      if (this.conversationHistory.length > MAX_HISTORY_EXCHANGES) {
        this.conversationHistory = this.conversationHistory.slice(0, MAX_HISTORY_EXCHANGES);
      }
      
      // Sauvegarder en AsyncStorage
      const historyData = {
        exchanges: this.conversationHistory,
        lastUpdated: Date.now(),
        version: '1.0'
      };
      
      await AsyncStorage.setItem(HISTORY_KEY, JSON.stringify(historyData));
      
      console.log('üíæ √âchange sauvegard√©. Total historique:', this.conversationHistory.length);
      
    } catch (error) {
      console.warn('üö® Erreur sauvegarde √©change:', error);
    }
  }

  /**
   * ‚úÖ NOUVEAU : STATS HISTORIQUE (DEBUG)
   */
  getHistoryStats() {
    return {
      count: this.conversationHistory.length,
      maxCount: MAX_HISTORY_EXCHANGES,
      exchanges: this.conversationHistory.map(exchange => ({
        userPreview: exchange.user.substring(0, 30) + '...',
        melunePreview: exchange.melune.substring(0, 30) + '...',
        timestamp: new Date(exchange.timestamp).toLocaleString()
      })),
      totalCharacters: this.conversationHistory.reduce((total, exchange) => 
        total + exchange.user.length + exchange.melune.length, 0)
    };
  }

  /**
   * ‚úÖ NOUVEAU : NETTOYAGE HISTORIQUE (DEBUG)
   */
  async clearHistory() {
    try {
      this.conversationHistory = [];
      await AsyncStorage.removeItem(HISTORY_KEY);
      console.log('üßπ Historique conversationnel nettoy√©');
    } catch (error) {
      console.warn('üö® Erreur nettoyage historique:', error);
    }
  }

  /**
   * üßπ NETTOYAGE CACHE (MODIFI√â)
   */
  async clearCache() {
    try {
      await AsyncStorage.removeItem(CACHE_KEY);
      this.cachedContext = null;
      // ‚úÖ NOUVEAU : Optionnel - garder historique ou non lors du clear cache
      console.log('üßπ Cache contexte nettoy√© (historique pr√©serv√©)');
    } catch (error) {
      console.warn('üö® Erreur nettoyage cache:', error);
    }
  }

  /**
   * üîÑ INVALIDATION CACHE (MODIFI√â)
   */
  async invalidateCache() {
    await this.clearCache();
    // ‚úÖ NOUVEAU : Recharger historique au prochain message
    this.conversationHistory = [];
    console.log('üîÑ Cache invalid√© - recalcul au prochain message avec historique');
  }
}

// Export instance singleton
export default new ChatService(); 